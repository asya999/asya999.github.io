<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Arrays on Ask Asya </title>
    <link>http://asya999.github.io/tags/arrays/</link>
    <language>en-US</language>
    <author>Asya Kamsky</author>
    <rights>Copyright (c) 2016, Asya Kamsky; all rights reserved.</rights>
    <updated>Sun, 09 Oct 2016 00:00:00 UTC</updated>
    
    <item>
      <title>How do I match documents where all array elements match some predicate?</title>
      <link>http://asya999.github.io/post/matchallarrayelements/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 UTC</pubDate>
      <author>Asya Kamsky</author>
      <guid>http://asya999.github.io/post/matchallarrayelements/</guid>
      <description>

&lt;h3 id=&#34;question:292757d8f30706addf536c1c5ac8ae1a&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;I need to match all documents where every element of an array matches some predicate.  Can that be done?&lt;/p&gt;

&lt;h3 id=&#34;answer:292757d8f30706addf536c1c5ac8ae1a&#34;&gt;Answer:&lt;/h3&gt;

&lt;p&gt;Yes, the query to do this is actually quite simple to construct.&lt;/p&gt;

&lt;p&gt;Remember that when you match an array, MongoDB will &amp;ldquo;reach inside&amp;rdquo; the array to compare the predicate to every single
array element and return the document if the predicate matches at least one of them.  I like to tell MongoDB newbies
to think of arrays as a field that can hold many different values at the same time.  Once you start thinking of
arrays that way, it becomes a lot easier to understand that query like &amp;ldquo;where A is greater than 50 AND A is less than 10&amp;rdquo;
is not meaningless if &amp;ldquo;A&amp;rdquo; happens to be an array, because different array elements can satisfy the separate parts of
this query.&lt;/p&gt;

&lt;p&gt;What that means is that in order to make sure every array element matches some construct, you should negate that construct and then negate the query again.&lt;/p&gt;

&lt;p&gt;A simple example can probably help:&lt;/p&gt;

&lt;p&gt;Imagine you have this set of documents:
&lt;pre class=&#34;prettyprint&#34;&gt;
{ &amp;ldquo;a&amp;rdquo;: [ 1, 2, 3, 4 ] }
{ &amp;ldquo;a&amp;rdquo;: [ 3, 4, 5, 6 ] }
{ &amp;ldquo;a&amp;rdquo;: [ 5, 6, 7, 8 ] }
{ &amp;ldquo;a&amp;rdquo;: [ 1, 2, 3, 4, 5 ] }
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;How do you find all documents where &amp;ldquo;a&amp;rdquo; is less than 5?  That&amp;rsquo;s simple, just &lt;code&gt;db.coll.find({&amp;quot;a&amp;quot;:{&amp;quot;$lt&amp;quot;:5}})&lt;/code&gt; and we get back (unsurprisingly):
&lt;pre class=&#34;prettyprint&#34;&gt;
{ &amp;ldquo;a&amp;rdquo;: [ 1, 2, 3, 4 ] }
{ &amp;ldquo;a&amp;rdquo;: [ 3, 4, 5, 6 ] }
{ &amp;ldquo;a&amp;rdquo;: [ 1, 2, 3, 4, 5 ] }
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;This is because at least one element in each of these arrays matches our query predicate.  The third document has no elements that are less than 5.&lt;/p&gt;

&lt;p&gt;Now we want to get back only the documents which have &lt;em&gt;every&lt;/em&gt; element match the same predicate.  Another way of saying &amp;ldquo;I want every document where each element of array is less than 5&amp;rdquo; would be &amp;ldquo;I want every document where none of the elements are greater than or equal to 5&amp;rdquo;.  So we first negate our original query:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.coll.find({&amp;quot;a&amp;quot;:{&amp;quot;$gte&amp;quot;:5}})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then we negate the entire result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;db.coll.find({&amp;quot;$nor&amp;quot;:[{&amp;quot;a&amp;quot;:{&amp;quot;$gte&amp;quot;:5}}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and as you would expect, the result is:
&lt;pre class=&#34;prettyprint&#34;&gt;
{ &amp;ldquo;a&amp;rdquo;: [ 1, 2, 3, 4 ] }
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;When we deal with numbers, it&amp;rsquo;s easy to &amp;ldquo;negate&amp;rdquo; a condition, but with arrays, reasoning about &amp;ldquo;$not&amp;rdquo; and &amp;ldquo;$nor&amp;rdquo; can be tricky so let&amp;rsquo;s try again with strings where we can&amp;rsquo;t use &amp;ldquo;$gt&amp;rdquo; and &amp;ldquo;$lt&amp;rdquo; so easily.
&lt;pre class=&#34;prettyprint&#34;&gt;
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;, &amp;ldquo;3&amp;rdquo;, &amp;ldquo;4&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;3&amp;rdquo;, &amp;ldquo;4&amp;rdquo;, &amp;ldquo;5&amp;rdquo;, &amp;ldquo;6&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;5&amp;rdquo;, &amp;ldquo;6&amp;rdquo;, &amp;ldquo;7&amp;rdquo;, &amp;ldquo;8&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;, &amp;ldquo;3&amp;rdquo;, &amp;ldquo;4&amp;rdquo;, &amp;ldquo;5&amp;rdquo; ] }
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try the same thing we tried above where first we will look for a being one of the set &amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;4&amp;rdquo; and go from there.
&lt;pre class=&#34;prettyprint&#34;&gt;
db.coll.find({&amp;ldquo;a&amp;rdquo;:{&amp;ldquo;$in&amp;rdquo;:[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;4&amp;rdquo;]}})
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;, &amp;ldquo;3&amp;rdquo;, &amp;ldquo;4&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;3&amp;rdquo;, &amp;ldquo;4&amp;rdquo;, &amp;ldquo;5&amp;rdquo;, &amp;ldquo;6&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;1&amp;rdquo;, &amp;ldquo;2&amp;rdquo;, &amp;ldquo;3&amp;rdquo;, &amp;ldquo;4&amp;rdquo;, &amp;ldquo;5&amp;rdquo; ] }
db.coll.find({&amp;ldquo;a&amp;rdquo;:{&amp;ldquo;$nin&amp;rdquo;:[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;4&amp;rdquo;]}})
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;5&amp;rdquo;, &amp;ldquo;6&amp;rdquo;, &amp;ldquo;7&amp;rdquo;, &amp;ldquo;8&amp;rdquo; ] }
&lt;/pre&gt;
What happened?  Did you expect to get back every document which had an element that isn&amp;rsquo;t one of the four in the &amp;ldquo;$nin&amp;rdquo; list?  Recall that [&amp;ldquo;$nin&amp;rdquo;][2] is the same as saying [&amp;ldquo;$not&amp;rdquo;][3] &amp;ldquo;$in&amp;rdquo; which is the same as saying &amp;ldquo;take the set of documents which satisfy the query &lt;code&gt;{&amp;quot;$in&amp;quot;:[&amp;lt;list&amp;gt;]}&lt;/code&gt; and give me the rest of the documents.   So how do we express the query that we want all documents which have an &lt;em&gt;element&lt;/em&gt; that isn&amp;rsquo;t one of our list?&lt;/p&gt;

&lt;p&gt;Whenever the question (or query) involves an element of an array, there&amp;rsquo;s a good chance that you should be using [&amp;ldquo;$elemMatch&amp;rdquo;][1] to express it.   Commonly, we use &amp;ldquo;$elemMatch&amp;rdquo; to express that we want the same array element to match multiple conditions in the query predicates, but it&amp;rsquo;s also correct to use it when you are trying to negate the meaning of a query by applying the negation to the element of an array, rather than to the document selection as a whole.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
// find me all documents where at least one array element is *not* on our list
db.coll.find({&#34;a&#34;:{&#34;$elemMatch&#34;:{&#34;$nin&#34;:[&#34;1&#34;,&#34;2&#34;,&#34;3&#34;,&#34;4&#34;]}}})
{ &#34;a&#34; : [ &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34;, &#34;5&#34; ] }
{ &#34;a&#34; : [ &#34;3&#34;, &#34;4&#34;, &#34;5&#34;, &#34;6&#34; ] }
{ &#34;a&#34; : [ &#34;5&#34;, &#34;6&#34;, &#34;7&#34;, &#34;8&#34; ] }
// now we negate the entire query
db.coll.find({&#34;$nor&#34;:[{&#34;a&#34;:{&#34;$elemMatch&#34;:{&#34;$nin&#34;:[&#34;1&#34;,&#34;2&#34;,&#34;3&#34;,&#34;4&#34;]}}}]})
{ &#34;a&#34; : [ &#34;1&#34;, &#34;2&#34;, &#34;3&#34;, &#34;4&#34; ] }
&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s another tricky example involving a regular expression - while you can negate a regular expression, you may inadvertantly limit matching to string types only, and when you have mixed type arrays (not recommended, but it happens) that&amp;rsquo;s won&amp;rsquo;t give you desired results.&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
{ &#34;a&#34; : [ &#34;str1&#34;, &#34;str2&#34;, &#34;str3&#34;, &#34;notstr&#34; ] }
{ &#34;a&#34; : [ &#34;str1&#34;, &#34;str2&#34;, &#34;str3&#34;, &#34;str4&#34; ] }
{ &#34;a&#34; : [ 1, 2, 3, 4, 5 ] }
{ &#34;a&#34; : [ 5, 6, 7, 8, 9 ] }
{ &#34;a&#34; : [ &#34;str1&#34;, 0, 10 ] }
&lt;/pre&gt;

&lt;p&gt;Say I want to get back just documents that have &lt;em&gt;all&lt;/em&gt; its &amp;ldquo;a&amp;rdquo; elements start with characters &amp;ldquo;str&amp;rdquo;. Let&amp;rsquo;s look at some queries and their results:
&lt;pre class=&#34;prettyprint&#34;&gt;
db.coll.find({&amp;ldquo;a&amp;rdquo;:/^str/})
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;str1&amp;rdquo;, &amp;ldquo;str2&amp;rdquo;, &amp;ldquo;str3&amp;rdquo;, &amp;ldquo;notstr&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;str1&amp;rdquo;, &amp;ldquo;str2&amp;rdquo;, &amp;ldquo;str3&amp;rdquo;, &amp;ldquo;str4&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;str1&amp;rdquo;, 0, 10 ] }
db.coll.find({&amp;ldquo;a&amp;rdquo;:{$not:/^str/}})
{ &amp;ldquo;a&amp;rdquo; : [ 1, 2, 3, 4, 5 ] }
{ &amp;ldquo;a&amp;rdquo; : [ 5, 6, 7, 8, 9 ] }
// negate regular expression:
db.coll.find({&amp;ldquo;a&amp;rdquo;:/^(?!str)/})
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;str1&amp;rdquo;, &amp;ldquo;str2&amp;rdquo;, &amp;ldquo;str3&amp;rdquo;, &amp;ldquo;notstr&amp;rdquo; ] }
db.coll.find({&amp;ldquo;a&amp;rdquo;:{$not:/^(?!str)/}})
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;str1&amp;rdquo;, &amp;ldquo;str2&amp;rdquo;, &amp;ldquo;str3&amp;rdquo;, &amp;ldquo;str4&amp;rdquo; ] }
{ &amp;ldquo;a&amp;rdquo; : [ 1, 2, 3, 4, 5 ] }
{ &amp;ldquo;a&amp;rdquo; : [ 5, 6, 7, 8, 9 ] }
{ &amp;ldquo;a&amp;rdquo; : [ &amp;ldquo;str1&amp;rdquo;, 0, 10 ] }
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Any surprises here?   First, we see that negated regular expression query only matches elements of type string.  We also see that &amp;ldquo;$not&amp;rdquo; added to any regex query returns the complement of documents that were returned without &amp;ldquo;$not&amp;rdquo; present.  That&amp;rsquo;s not what we need when trying to get all documents with every element that satisfies the predicate.   Let&amp;rsquo;s see if &amp;ldquo;$elemMatch&amp;rdquo; gives us what we want:&lt;/p&gt;

&lt;pre class=&#34;prettyprint&#34;&gt;
// note that $elemMatch requires a subdocument so we use [&#34;$regex&#34;][4] rather than / / syntax
db.coll.find({&#34;a&#34;:{&#34;$elemMatch&#34;:{&#34;$regex&#34;:&#34;^str&#34;}}})
{ &#34;a&#34; : [ &#34;str1&#34;, &#34;str2&#34;, &#34;str3&#34;, &#34;notstr&#34; ] }
{ &#34;a&#34; : [ &#34;str1&#34;, &#34;str2&#34;, &#34;str3&#34;, &#34;str4&#34; ] }
{ &#34;a&#34; : [ &#34;str1&#34;, 0, 10 ] }
db.coll.find({&#34;a&#34;:{&#34;$elemMatch&#34;:{$not:/^str/}}})
{ &#34;a&#34; : [ &#34;str1&#34;, &#34;str2&#34;, &#34;str3&#34;, &#34;notstr&#34; ] }
{ &#34;a&#34; : [ 1, 2, 3, 4, 5 ] }
{ &#34;a&#34; : [ 5, 6, 7, 8, 9 ] }
{ &#34;a&#34; : [ &#34;str1&#34;, 0, 10 ] }
// bingo!  we got back every document that had something that would NOT match &#34;^str&#34;
// now we just negate that whole query
db.coll.find({&#34;$nor&#34;:[{&#34;a&#34;:{&#34;$elemMatch&#34;:{$not:/^str/}}}]})
{ &#34;a&#34; : [ &#34;str1&#34;, &#34;str2&#34;, &#34;str3&#34;, &#34;str4&#34; ] }
&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s try it on a more complex document structure with a more complex predicate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &amp;quot;b&amp;quot; : [ { &amp;quot;x&amp;quot; : 1, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-04-09T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 2, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-04-19T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 3, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2015-12-12T00:00:00Z&amp;quot;) } ] }
{ &amp;quot;b&amp;quot; : [ { &amp;quot;x&amp;quot; : 1, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-02-05T12:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 9, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-03-01T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 5, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2015-11-01T00:00:00Z&amp;quot;) } ] }
{ &amp;quot;b&amp;quot; : [ { &amp;quot;x&amp;quot; : 3, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-01-31T12:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 6, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-03-01T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 1, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-10-01T00:00:00Z&amp;quot;) } ] }
{ &amp;quot;b&amp;quot; : [ { &amp;quot;x&amp;quot; : 1, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-04-09T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 2, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-04-19T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 3, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-09-21T00:00:00Z&amp;quot;) } ] }
{ &amp;quot;b&amp;quot; : [ { &amp;quot;x&amp;quot; : 1, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-04-09T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 2, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-04-19T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 3, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-01-01T00:00:00Z&amp;quot;) }, { &amp;quot;x&amp;quot; : 4, &amp;quot;y&amp;quot; : ISODate(&amp;quot;2016-01-01T00:00:00Z&amp;quot;) } ] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If our predicate was just about &amp;ldquo;b.x&amp;rdquo; or just about &amp;ldquo;b.y&amp;rdquo; we would use &amp;ldquo;$elemMatch&amp;rdquo; rather than dotted notation to run a query just like our first example.  To find all documents where &amp;ldquo;b.x&amp;rdquo; is either 1, 2 or 3, we can go through these steps (assume all queries ask in projection just for the field I&amp;rsquo;m querying by):
````
// find all documents where &amp;ldquo;b.x&amp;rdquo; is one of 1,2,3
db.coll.find({&amp;ldquo;b.x&amp;rdquo;:{$in:[1,2,3]}})
{ &amp;ldquo;b&amp;rdquo; : [ { &amp;ldquo;x&amp;rdquo; : 1 }, { &amp;ldquo;x&amp;rdquo; : 2 }, { &amp;ldquo;x&amp;rdquo; : 3 } ] }
{ &amp;ldquo;b&amp;rdquo; : [ { &amp;ldquo;x&amp;rdquo; : 1 }, { &amp;ldquo;x&amp;rdquo; : 9 }, { &amp;ldquo;x&amp;rdquo; : 5 } ] }
{ &amp;ldquo;b&amp;rdquo; : [ { &amp;ldquo;x&amp;rdquo; : 3 }, { &amp;ldquo;x&amp;rdquo; : 6 }, { &amp;ldquo;x&amp;rdquo; : 1 } ] }
{ &amp;ldquo;b&amp;rdquo; : [ { &amp;ldquo;x&amp;rdquo; : 1 }, { &amp;ldquo;x&amp;rdquo; : 2 }, { &amp;ldquo;x&amp;rdquo; : 3 } ] }
{ &amp;ldquo;b&amp;rdquo; : [ { &amp;ldquo;x&amp;rdquo; : 1 }, { &amp;ldquo;x&amp;rdquo; : 2 }, { &amp;ldquo;x&amp;rdquo; : 3 }, { &amp;ldquo;x&amp;rdquo; : 4 } ] }
// another way of structuring this query is with $or
db.coll.find({$or:[{&amp;ldquo;b.x&amp;rdquo;:1},{&amp;ldquo;b.x&amp;rdquo;:2},{&amp;ldquo;b.x&amp;rdquo;:3}]})
db.coll.find({$and:[{&amp;ldquo;b.x&amp;rdquo;:1},{&amp;ldquo;b.x&amp;rdquo;:2},{&amp;ldquo;b.x&amp;rdquo;:3}]})&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to Model Dynamic Attributes</title>
      <link>http://asya999.github.io/post/dynamicattributes/</link>
      <pubDate>Tue, 15 Apr 2014 00:00:00 UTC</pubDate>
      <author>Asya Kamsky</author>
      <guid>http://asya999.github.io/post/dynamicattributes/</guid>
      <description>

&lt;h3 id=&#34;question:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve heard that MongoDB can be effectively used to model &amp;ldquo;dynamic attributes&amp;rdquo; - where you don&amp;rsquo;t know up front all the different attributes and not all attributes apply to all items.  Can you describe how that can be done, and in particular how it can be effectively indexed?&lt;/p&gt;

&lt;h3 id=&#34;answer:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;Answer:&lt;/h3&gt;

&lt;h5 id=&#34;the-problem:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;The problem:&lt;/h5&gt;

&lt;p&gt;Imagine you are building an e-commerce site and you aspire to be as big as amazon.com some day, which means you will be selling many different types of products.  It&amp;rsquo;s easy to see that there will be sets of attributes that will only apply to some of the products you sell.&lt;/p&gt;

&lt;p&gt;Product document may look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;XRD12349&amp;quot;,
  type: &amp;quot;book&amp;quot;,
  title: &amp;quot;MongoDB, The Definitive Guide&amp;quot;,
  ISBN: &amp;quot;xxx&amp;quot;,
  author: [ &amp;quot;Kristina Chodorow&amp;quot;, &amp;quot;Mike Dieroff&amp;quot;],
  genre: [&amp;quot;computing&amp;quot;, &amp;quot;databases&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;Y32944EW&amp;quot;,
  type: &amp;quot;shoes&amp;quot;,
  manufacturer: &amp;quot;ShoesForAll&amp;quot;,
  color: &amp;quot;blue&amp;quot;,
  style: &amp;quot;comfort&amp;quot;,
  size: &amp;quot;7B&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see how it would be extremely challenging to manage a collection that has an incredibly wide variety of document &amp;ldquo;shapes&amp;rdquo;.  Now, while some people call MongoDB &amp;ldquo;schemaless&amp;rdquo; I am not a fan of this designation.  The schema of each document is defined by the document itself.  To be able to build a robust applications you need to decide what the schema of the documents will be, otherwise your application will spend as much time examining the documents to learn their schema as providing actual functionality.&lt;/p&gt;

&lt;h5 id=&#34;possible-solutions:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;Possible solutions:&lt;/h5&gt;

&lt;p&gt;One way to index the attributes you want to be able to search by is by creating an index on each such attribute in a schema like the one above.  This is not practical, even if you use &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;&amp;ldquo;sparse&amp;rdquo; indexes&lt;/a&gt; (since many attributes will be set only on a small subset of the products), because you may end up with dozens, if not hundreds of indexes.  In addition, every time a new attribute is introduced, a new index has to be added on the collection.  Not very practical.&lt;/p&gt;

&lt;p&gt;The other solution, which is a nice generalization of storing attributes which are numerous and not known up-front, is to use an array of key-value pairs.&lt;/p&gt;

&lt;p&gt;Our two sample documents might then become:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;XRD12349&amp;quot;,
  type: &amp;quot;book&amp;quot;,
  attr: [
      { &amp;quot;k&amp;quot;: &amp;quot;title&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;MongoDB, The Definitive Guide, 1st Edition&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;ISBN&amp;quot;,
        &amp;quot;v&amp;quot;: &amp;quot;xxx&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;author&amp;quot;,
        &amp;quot;v&amp;quot;: &amp;quot;Kristina Chodorow&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;author&amp;quot;,
        &amp;quot;v&amp;quot;: &amp;quot;Mike Dieroff&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;genre&amp;quot;,
        &amp;quot;v&amp;quot;: [&amp;quot;computing&amp;quot;, &amp;quot;databases&amp;quot;] 
      }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;Y32944EW&amp;quot;,
  type: &amp;quot;shoes&amp;quot;,
  attr: [
      { &amp;quot;k&amp;quot;: &amp;quot;manufacturer&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;ShoesForAll&amp;quot;,
      },
      { &amp;quot;k&amp;quot;: &amp;quot;color&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;blue&amp;quot;,
      },
      { &amp;quot;k&amp;quot;: &amp;quot;style&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;comfort&amp;quot;,
      },
      { &amp;quot;k&amp;quot;: &amp;quot;size&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;7B&amp;quot;
      }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that for an attribute that can have multiple values you have a choice of storing it as an array in a single &amp;ldquo;key&amp;rdquo; or you can repeat keys that can have more than one value.&lt;/p&gt;

&lt;p&gt;Now we can index all of these attribute values with the following:&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.ensureIndex( { &#34;attr.k&#34;:1, &#34;attr.v&#34;:1 } )
&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at how the queries will execute and use the index by using the &amp;ldquo;explain()&amp;rdquo; helper in MongoDB shell.  When filtering based on attribute key-value pair, remember to use the &lt;code&gt;$elemMatch&lt;/code&gt; operator to indicate that both conditions must be satisfied by the same element of the array.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.find( 
                                { &#34;attr&#34;: { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;size&#34;, &#34;v&#34;:&#34;8B&#34; } }
                     } ).explain()
{
    &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
    &#34;isMultiKey&#34; : true,
    &#34;n&#34; : 104,
    &#34;nscannedObjects&#34; : 104,
    &#34;nscanned&#34; : 104,
    &#34;nscannedObjectsAllPlans&#34; : 104,
    &#34;nscannedAllPlans&#34; : 104,
    &#34;scanAndOrder&#34; : false,
    &#34;indexOnly&#34; : false,
    &#34;nYields&#34; : 0,
    &#34;nChunkSkips&#34; : 0,
    &#34;millis&#34; : 2,
    &#34;indexBounds&#34; : {
        &#34;attr.k&#34; : [
            [
                &#34;size&#34;,
                &#34;size&#34;
            ]
        ],
        &#34;attr.v&#34; : [
            [
                &#34;8B&#34;,
                &#34;8B&#34;
            ]
        ]
    },
    &#34;server&#34; : &#34;asyasmacbook.local:27017&#34;,
    &#34;filterSet&#34; : false
}
&lt;/pre&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.find(
                  { &#34;attr&#34; :  { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;color&#34;, &#34;v&#34;:&#34;blue&#34;}}
              } ).explain()
{
    &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
    &#34;isMultiKey&#34; : true,
    &#34;n&#34; : 98,
    &#34;nscannedObjects&#34; : 98,
    &#34;nscanned&#34; : 98,
    &#34;nscannedObjectsAllPlans&#34; : 98,
    &#34;nscannedAllPlans&#34; : 98,
    &#34;scanAndOrder&#34; : false,
    &#34;indexOnly&#34; : false,
    &#34;nYields&#34; : 0,
    &#34;nChunkSkips&#34; : 0,
    &#34;millis&#34; : 0,
    &#34;indexBounds&#34; : {
        &#34;attr.k&#34; : [
            [
                &#34;color&#34;,
                &#34;color&#34;
            ]
        ],
        &#34;attr.v&#34; : [
            [
                &#34;blue&#34;,
                &#34;blue&#34;
            ]
        ]
    },
    &#34;server&#34; : &#34;asyasmacbook.local:27017&#34;,
    &#34;filterSet&#34; : false
}
&lt;/pre&gt;

&lt;p&gt;Now I&amp;rsquo;ll use both criteria, and I&amp;rsquo;ll add another one for attribute &amp;ldquo;style&amp;rdquo; - since I want to match only when &lt;em&gt;all&lt;/em&gt; are true (rather than when any is true) I will use the &lt;code&gt;$all&lt;/code&gt; operator.  Passing &amp;ldquo;true&amp;rdquo; as an argument to explain will show all considered plans and not just the winning plan.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.find( { &#34;attr&#34; : { &#34;$all&#34; : [ 
                    { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;style&#34;, &#34;v&#34;:&#34;comfort&#34; } }, 
                    { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;color&#34;, &#34;v&#34;:&#34;blue&#34; } },
                    { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;size&#34;, &#34;v&#34;:&#34;8B&#34; } } 
                  ] } } ).explain(true)
{
    &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
    &#34;isMultiKey&#34; : true,
    &#34;n&#34; : 1,
    &#34;nscannedObjects&#34; : 98,
    &#34;nscanned&#34; : 98,
    &#34;nscannedObjectsAllPlans&#34; : 296,
    &#34;nscannedAllPlans&#34; : 298,
    &#34;scanAndOrder&#34; : false,
    &#34;indexOnly&#34; : false,
    &#34;nYields&#34; : 2,
    &#34;nChunkSkips&#34; : 0,
    &#34;millis&#34; : 1,
    &#34;indexBounds&#34; : {
        &#34;attr.k&#34; : [
            [
                &#34;color&#34;,
                &#34;color&#34;
            ]
        ],
        &#34;attr.v&#34; : [
            [
                &#34;blue&#34;,
                &#34;blue&#34;
            ]
        ]
    },
    &#34;allPlans&#34; : [
        {
            &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
            &#34;isMultiKey&#34; : true,
            &#34;n&#34; : 1,
            &#34;nscannedObjects&#34; : 98,
            &#34;nscanned&#34; : 98,
            &#34;scanAndOrder&#34; : false,
            &#34;indexOnly&#34; : false,
            &#34;nChunkSkips&#34; : 0,
            &#34;indexBounds&#34; : {
                &#34;attributes.name&#34; : [
                    [
                        &#34;color&#34;,
                        &#34;color&#34;
                    ]
                ],
                &#34;attributes.value&#34; : [
                    [
                        &#34;blue&#34;,
                        &#34;blue&#34;
                    ]
                ]
            }
        },
        {
            &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
            &#34;isMultiKey&#34; : true,
            &#34;n&#34; : 1,
            &#34;nscannedObjects&#34; : 99,
            &#34;nscanned&#34; : 100,
            &#34;scanAndOrder&#34; : false,
            &#34;indexOnly&#34; : false,
            &#34;nChunkSkips&#34; : 0,
            &#34;indexBounds&#34; : {
                &#34;attributes.name&#34; : [
                    [
                        &#34;style&#34;,
                        &#34;style&#34;
                    ]
                ],
                &#34;attributes.value&#34; : [
                    [
                        &#34;comfort&#34;,
                        &#34;comfort&#34;
                    ]
                ]
            }
        },
        {
            &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
            &#34;isMultiKey&#34; : true,
            &#34;n&#34; : 1,
            &#34;nscannedObjects&#34; : 99,
            &#34;nscanned&#34; : 100,
            &#34;scanAndOrder&#34; : false,
            &#34;indexOnly&#34; : false,
            &#34;nChunkSkips&#34; : 0,
            &#34;indexBounds&#34; : {
                &#34;attributes.name&#34; : [
                    [
                        &#34;size&#34;,
                        &#34;size&#34;
                    ]
                ],
                &#34;attributes.value&#34; : [
                    [
                        &#34;8B&#34;,
                        &#34;8B&#34;
                    ]
                ]
            }
        }
    ],
    &#34;server&#34; : &#34;asyasmacbook.local:27017&#34;,
    &#34;filterSet&#34; : false,
    &#34;stats&#34; : {
        &#34;type&#34; : &#34;KEEP_MUTATIONS&#34;,
        &#34;works&#34; : 100,
        &#34;yields&#34; : 2,
        &#34;unyields&#34; : 2,
        &#34;invalidates&#34; : 0,
        &#34;advanced&#34; : 1,
        &#34;needTime&#34; : 97,
        &#34;needFetch&#34; : 0,
        &#34;isEOF&#34; : 1,
        &#34;children&#34; : [
            {
                &#34;type&#34; : &#34;FETCH&#34;,
                &#34;works&#34; : 99,
                &#34;yields&#34; : 2,
                &#34;unyields&#34; : 2,
                &#34;invalidates&#34; : 0,
                &#34;advanced&#34; : 1,
                &#34;needTime&#34; : 97,
                &#34;needFetch&#34; : 0,
                &#34;isEOF&#34; : 1,
                &#34;alreadyHasObj&#34; : 0,
                &#34;forcedFetches&#34; : 0,
                &#34;matchTested&#34; : 1,
                &#34;children&#34; : [
                    {
                        &#34;type&#34; : &#34;IXSCAN&#34;,
                        &#34;works&#34; : 98,
                        &#34;yields&#34; : 2,
                        &#34;unyields&#34; : 2,
                        &#34;invalidates&#34; : 0,
                        &#34;advanced&#34; : 98,
                        &#34;needTime&#34; : 0,
                        &#34;needFetch&#34; : 0,
                        &#34;isEOF&#34; : 1,
                        &#34;keyPattern&#34; : &#34;{ attr.k: 1.0, attr.v: 1.0 }&#34;,
                        &#34;boundsVerbose&#34; : &#34;field #0[&#39;attr.k&#39;]: [\&#34;color\&#34;, \&#34;color\&#34;], field #1[&#39;attr.v&#39;]: [\&#34;blue\&#34;, \&#34;blue\&#34;]&#34;,
                        &#34;isMultiKey&#34; : 1,
                        &#34;yieldMovedCursor&#34; : 0,
                        &#34;dupsTested&#34; : 98,
                        &#34;dupsDropped&#34; : 0,
                        &#34;seenInvalidated&#34; : 0,
                        &#34;matchTested&#34; : 0,
                        &#34;keysExamined&#34; : 98,
                        &#34;children&#34; : [ ]
                    }
                ]
            }
        ]
    }
}
&lt;/pre&gt;

&lt;p&gt;What does this mean?   If we look at &lt;code&gt;allPlans&lt;/code&gt; we see that the optimizer tried our attribute index separately (but in parallel) with each of the clauses inside the $all array.  The winning plan was for &amp;ldquo;color&amp;rdquo; attribute because it turned out to be the most selective.&lt;/p&gt;

&lt;p&gt;In MongoDB 2.4 this was not possible and unfortunately the optimizer would use the index for the first clause of the &lt;code&gt;$all&lt;/code&gt; expression.  If it happened to have low selectivity, then you didn&amp;rsquo;t get as good performance as you might have, had you ordered your conditions differently.  In 2.6 the order of expressions inside &lt;code&gt;$all&lt;/code&gt; does not make a difference as the one that&amp;rsquo;s most selective will be the one used by the query optimizer.&lt;/p&gt;

&lt;p&gt;Depending on how you need to query your attributes, there are different ways of structuring the attribute array.  You can use key-value pairs as I showed, you can use the attribute name as the key value, or you can even store a single string value &amp;ldquo;attrname::attrvalue&amp;rdquo; - best thing is to take a look at the types of queries and updates you will be running and try it different ways, benchmark which one works best and use that one.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Schema Design - Blog Posts and Comments revisited</title>
      <link>http://asya999.github.io/post/blogsandcommentsrevisted/</link>
      <pubDate>Sat, 29 Mar 2014 00:00:00 UTC</pubDate>
      <author>Asya Kamsky</author>
      <guid>http://asya999.github.io/post/blogsandcommentsrevisted/</guid>
      <description>

&lt;h3 id=&#34;question:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;I have a question about whether I should store comments inside the blog post entry or in a separate collection. It&amp;rsquo;d be nice to see examples of how to access various fields in both cases, how to index and in general how to know when to embed and when to link.&lt;/p&gt;

&lt;h3 id=&#34;answer:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Answer:&lt;/h3&gt;

&lt;h4 id=&#34;the-blog-schema:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;The Blog Schema&lt;/h4&gt;

&lt;p&gt;There has been a lot of discussion and write-ups about how to model a simple blog that allows comments on posts - it&amp;rsquo;s a fairly simple example that everyone can understand, and at the same time it offers several opportunities to choose different ways to structure the schema.  The example usually consists of four concepts: users(or authors), posts, tags on posts and comments on posts.&lt;/p&gt;

&lt;h5 id=&#34;authors:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Authors&lt;/h5&gt;

&lt;p&gt;Typically everyone agrees that the authors or users are stored in a  collection of their own where you keep their information - everything from their username, password, when they last logged in, when they signed up for the service, etc.&lt;/p&gt;

&lt;h5 id=&#34;posts:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Posts&lt;/h5&gt;

&lt;p&gt;There is also little argument that posts should be stored separately from authors - I don&amp;rsquo;t think I&amp;rsquo;ve ever heard anyone advocate for embedding posts within author document - that makes no sense for many reason, not the least of them are the fact that you want to avoid unbounded growth of the author document, and querying over posts is a natural function of the use case so posts really should be first class object.&lt;/p&gt;

&lt;p&gt;What isn&amp;rsquo;t always agreed on is whether the author of the post should have just their unique primary key (or username) saved in each post or whether some of the information, like their full name, should also be denormalized into each post.&lt;/p&gt;

&lt;h5 id=&#34;tags:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Tags&lt;/h5&gt;

&lt;p&gt;Tags being simple strings should be stored inside the post document.  The it advantage of document model over relational is that it allows you to embed an array with multiple values without sacrificing the ability to index the tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &amp;quot;_id&amp;quot; : &amp;lt;Id&amp;gt;,
    &amp;quot;author&amp;quot; :  { &amp;quot;id&amp;quot; :  &amp;lt;authorId&amp;gt;, &amp;quot;name&amp;quot; :  &amp;quot;Asya Kamsky&amp;quot; },
    &amp;quot;tags&amp;quot; :  [ &amp;quot;schema&amp;quot;, &amp;quot;embed&amp;quot;, &amp;quot;link&amp;quot; ],
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can index tags with &lt;code&gt;db.posts.ensureIndex( { tags:1 } )&lt;/code&gt; which will be used in queries like
    db.posts.find( { &amp;ldquo;tags&amp;rdquo; : { &amp;ldquo;$in&amp;rdquo;:  [&amp;ldquo;schema&amp;rdquo;, &amp;ldquo;performance&amp;rdquo;] } } )&lt;/p&gt;

&lt;p&gt;You probably noticed that I happen to think it&amp;rsquo;s right to denormalize the author&amp;rsquo;s name into the post - I&amp;rsquo;m a strong believer in optimizing for the common case, not exceptional one&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; and I think optimizing query performance is more important than trying to minimize storage at the cost of performance.&lt;/p&gt;

&lt;h5 id=&#34;comments:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Comments&lt;/h5&gt;

&lt;p&gt;Comment documents, or rather where to store them, usually generates the most discussion and disagreement.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s consider both options and see what we can gain from each:&lt;/p&gt;

&lt;h6 id=&#34;embed-comments:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;embed comments&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;{
     _id: &amp;lt;Id&amp;gt;,
     author: { id: &amp;lt;authorId&amp;gt;, name: &amp;quot;Asya Kamsky&amp;quot; },
     tags: [ &amp;quot;schema&amp;quot;, &amp;quot;embed&amp;quot;, &amp;quot;link&amp;quot; ],
     comments: [
         { author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Joe Shmoe&amp;quot;}, 
           date:ISODate(&amp;quot; &amp;quot;), 
           text:&amp;quot;Blah Blah Blah&amp;quot; },
         { author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Jane Doe&amp;quot;}, 
           date:ISODate(&amp;quot; &amp;quot;), 
           text:&amp;quot;Blah Blah Blah&amp;quot; },
         { author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Asya Kamsky&amp;quot;}, 
           date:ISODate(&amp;quot; &amp;quot;), 
           text:&amp;quot;Blah Blah Blah&amp;quot; },
         ...
     ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to other indexes we already plan to have on posts, we will probably need to add several indexes to support querying for comments or by comments.  For example, when someone logs in, I can see wanting to show them all the threads/posts that they commented on, which means we need to index on &amp;ldquo;comments.author.id&amp;rdquo; so that we can query for posts that this author commented on.  We also might need to include fields inside the comments array to track which comments are responses to which other comments, and the biggest downside of them all, if the discussion in comments gets really heated, we will end up with a huge array inside this post.&lt;/p&gt;

&lt;h6 id=&#34;have-separate-comments-collection:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;have separate comments collection&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;{  post : &amp;lt;postId&amp;gt;,
    author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Joe Shmoe&amp;quot;}, 
    date:ISODate(&amp;quot; &amp;quot;), 
    text:&amp;quot;Blah Blah Blah&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A collection of comments would have to have an index on the postId so that we can look up the comments for a particular post, probably compound index with date so that we can query for the most recent posts.  We would want to index author.id and date as well.  But the nice thing is that here we can control how many comments we want returned, and even though querying for all comments for a post might involve some random IO, we can minimize it by only querying for as many comments as we intend to display.  The fact is that most of the time the reader of the blog post won&amp;rsquo;t even look at the comments, and if they do then they might read a few and never click on &amp;ldquo;show more&amp;rdquo; which we would normally have.&lt;/p&gt;

&lt;p&gt;Is there a third option?&lt;/p&gt;

&lt;h6 id=&#34;hybrid-option:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;hybrid option&lt;/h6&gt;

&lt;p&gt;The nice thing about flexible schema is that in cases like these you can keep comments in separate collection but also choose to denormalize some small number of comments into the post itself, either first few or the last few or whatever fits your requirements best.&lt;/p&gt;

&lt;p&gt;This hybrid approach may be analogous to the product collection for an e-commerce site where they store reviews of products separately from the product itself, but keep the highest voted reviews  (one positive and one negative) embedded in the product. This is a good schema because when you display the product, you want to display a few most helpful reviews, but you don&amp;rsquo;t need to display all the reviews at that time.&lt;/p&gt;

&lt;h4 id=&#34;summary:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Summary&lt;/h4&gt;

&lt;p&gt;The general principal to use when trying to decide between embedding and linking is this:
- consider which objects are first class entities and which are properties of such entities
- consider what your use case requires to display fast and what allows for additional queries
- when two choices both seem to be viable, prototype both and see which works better&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;Someone always brings up the possibility that the author will change their name, as if that&amp;rsquo;s an everyday occurrence
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Why shouldn&#39;t I embed large arrays in my documents?</title>
      <link>http://asya999.github.io/post/largeembeddedarrays/</link>
      <pubDate>Thu, 13 Feb 2014 00:00:00 UTC</pubDate>
      <author>Asya Kamsky</author>
      <guid>http://asya999.github.io/post/largeembeddedarrays/</guid>
      <description>

&lt;p&gt;+++
Categories = [&amp;ldquo;MongoDB&amp;rdquo;]
Title= &amp;ldquo;Why shouldn&amp;rsquo;t I embed large arrays in my documents?&amp;rdquo;
Date= &amp;ldquo;2014-02-13&amp;rdquo;
Slug= &amp;ldquo;largeembeddedarrays&amp;rdquo;
Tags= [&amp;ldquo;schema&amp;rdquo;,&amp;ldquo;performance&amp;rdquo;,&amp;ldquo;arrays&amp;rdquo;,&amp;ldquo;mongodb&amp;rdquo;]
+++&lt;/p&gt;

&lt;h3 id=&#34;question:b03b8c475184befd19c41be5b8f8950d&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;Why shouldn&amp;rsquo;t I embed large arrays in my documents?  It seems incredibly convenient and intuitive but I&amp;rsquo;ve heard there are performance penalties.  What causes them and how do I know if I should avoid using arrays?&lt;/p&gt;

&lt;h3 id=&#34;answer:b03b8c475184befd19c41be5b8f8950d&#34;&gt;Answer:&lt;/h3&gt;

&lt;p&gt;Arrays are wonderful when used properly.  When talking about performance, the main reason to be wary of arrays is when they grow without bounds.&lt;/p&gt;

&lt;p&gt;Imagine you create a document:
&lt;pre class=&#34;prettyprint&#34;&gt;
{ user: &amp;ldquo;Asya&amp;rdquo;,
  email: &amp;ldquo;asya@mongodb.com&amp;rdquo;,
  twitter: [&amp;ldquo;@asya999&amp;rdquo;, &amp;ldquo;@ask-asya&amp;rdquo;]
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Notice that twitter field is an array.  That&amp;rsquo;s perfectly fine and excellent - we don&amp;rsquo;t want to create a separate collection like we&amp;rsquo;d have to do in relational model, just because a person might have multiple twitter accounts/handles.&lt;/p&gt;

&lt;p&gt;Now that the document has been created, a certain amount of space has been allocated for it.  If we continue growing the document by adding new fields to it, it will have to be moved and a larger allocation will be made for it because MongoDB dynamically tracks how often documents outgrow their allocation and tries to allocate more space for newly written or moved documents to account for the future growth.&lt;/p&gt;

&lt;p&gt;Compare the cost of an update to a document when you can make an in-place change, versus rewriting the entire document somewhere else.  First, instead of just rewriting part of a document &amp;ldquo;in place&amp;rdquo; we have to allocate new space for it.  We have to rewrite the entire document, put the space that it used to occupy on the free list so that it can get re-used, and then repoint all the index entries that used to point to the old document location to the new location.  All of this must be done atomically, so your single write suddenly took a bit longer than a few microseconds that it used to take when the document didn&amp;rsquo;t have to move.&lt;/p&gt;

&lt;p&gt;Now imagine what happens if you add a new array field to the document representing something that&amp;rsquo;s not naturally bound the way someone&amp;rsquo;s twitter handles or shipping addresses would be bound.  What if we want to embed into this document every time I perform some activity, let&amp;rsquo;s say click on a like button, or make a comment on someone&amp;rsquo;s blog?&lt;/p&gt;

&lt;p&gt;First of all, we have to consider why we would want to do such a thing.  Normally, I would advise people to embed things that they always want to get back when they are fetching this document.  The flip side of this is that you don&amp;rsquo;t want to embed things in the document that you don&amp;rsquo;t want to get back with it.&lt;/p&gt;

&lt;p&gt;If you embed activity I perform into the document, it&amp;rsquo;ll work great at first because all of my activity is right there and with a single read you can get back everything you might want to show me: &amp;ldquo;you recently clicked on this and here are your last two comments&amp;rdquo; but what happens after six months go by and I don&amp;rsquo;t care about things I did a long time ago and you don&amp;rsquo;t want to show them to me unless I specifically go to look for some old activity?&lt;/p&gt;

&lt;p&gt;First, you&amp;rsquo;ll end up returning bigger and bigger document and caring about smaller and smaller portion of it.  But you can use projection to only return some of the array, the real pain is that the document on disk will get bigger and it will still all be read even if you&amp;rsquo;re only going to return part of it to the end user, but since my activity is not going to stop as long as I&amp;rsquo;m active, the document will continue growing and growing.&lt;/p&gt;

&lt;p&gt;The most obvious problem with this is eventually you&amp;rsquo;ll hit the 16MB document limit, but that&amp;rsquo;s not at all what you should be concerned about.  A document that continuously grows will incur higher and higher cost every time it has to get relocated on disk, and even if you take steps to mitigate the effects of fragmentation, your writes will overall be unnecessarily long, impacting overall performance of your entire application.&lt;/p&gt;

&lt;p&gt;There is one more thing that you can do that will completely kill your application&amp;rsquo;s performance and that&amp;rsquo;s to index this ever-increasing array.  What that means is that every single time the document with this array is relocated, the number of index entries that need to be updated is directly proportional to the number of indexed values in that document, and the bigger the array, the larger that number will be.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t want this to scare you from using arrays when they are a good fit for the data model - they are a powerful feature of the document database data model, but like all powerful tools, it needs to be used in the right circumstances and it should be used with care.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
