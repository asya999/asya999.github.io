<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ask Asya </title>
    <link>http://asya999.github.io/tags/arrays/</link>
    <language>en-us</language>
    <author></author>
    <rights>(C) 2014</rights>
    <updated>2014-04-15 00:00:00 &#43;0000 UTC</updated>

    
      
        <item>
          <title>How to Model Dynamic Attributes</title>
          <link>http://asya999.github.io/post/dynamicattributes/</link>
          <pubDate>Tue, 15 Apr 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://asya999.github.io/post/dynamicattributes/</guid>
          <description>

&lt;h3 id=&#34;question:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve heard that MongoDB can be effectively used to model &amp;ldquo;dynamic attributes&amp;rdquo; - where you don&amp;rsquo;t know up front all the different attributes and not all attributes apply to all items.  Can you describe how that can be done, and in particular how it can be effectively indexed?&lt;/p&gt;

&lt;h3 id=&#34;answer:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;Answer:&lt;/h3&gt;

&lt;h5 id=&#34;the-problem:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;The problem:&lt;/h5&gt;

&lt;p&gt;Imagine you are building an e-commerce site and you aspire to be as big as amazon.com some day, which means you will be selling many different types of products.  It&amp;rsquo;s easy to see that there will be sets of attributes that will only apply to some of the products you sell.&lt;/p&gt;

&lt;p&gt;Product document may look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;XRD12349&amp;quot;,
  type: &amp;quot;book&amp;quot;,
  title: &amp;quot;MongoDB, The Definitive Guide&amp;quot;,
  ISBN: &amp;quot;xxx&amp;quot;,
  author: [ &amp;quot;Kristina Chodorow&amp;quot;, &amp;quot;Mike Dieroff&amp;quot;],
  genre: [&amp;quot;computing&amp;quot;, &amp;quot;databases&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;Y32944EW&amp;quot;,
  type: &amp;quot;shoes&amp;quot;,
  manufacturer: &amp;quot;ShoesForAll&amp;quot;,
  color: &amp;quot;blue&amp;quot;,
  style: &amp;quot;comfort&amp;quot;,
  size: &amp;quot;7B&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see how it would be extremely challenging to manage a collection that has an incredibly wide variety of document &amp;ldquo;shapes&amp;rdquo;.  Now, while some people call MongoDB &amp;ldquo;schemaless&amp;rdquo; I am not a fan of this designation.  The schema of each document is defined by the document itself.  To be able to build a robust applications you need to decide what the schema of the documents will be, otherwise your application will spend as much time examining the documents to learn their schema as providing actual functionality.&lt;/p&gt;

&lt;h5 id=&#34;possible-solutions:bfa6b69d18d3a970bc8ca44586b86424&#34;&gt;Possible solutions:&lt;/h5&gt;

&lt;p&gt;One way to index the attributes you want to be able to search by is by creating an index on each such attribute in a schema like the one above.  This is not practical, even if you use &lt;a href=&#34;http://docs.mongodb.org/manual/core/index-sparse/&#34;&gt;&amp;ldquo;sparse&amp;rdquo; indexes&lt;/a&gt; (since many attributes will be set only on a small subset of the products), because you may end up with dozens, if not hundreds of indexes.  In addition, every time a new attribute is introduced, a new index has to be added on the collection.  Not very practical.&lt;/p&gt;

&lt;p&gt;The other solution, which is a nice generalization of storing attributes which are numerous and not known up-front, is to use an array of key-value pairs.&lt;/p&gt;

&lt;p&gt;Our two sample documents might then become:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;XRD12349&amp;quot;,
  type: &amp;quot;book&amp;quot;,
  attr: [
      { &amp;quot;k&amp;quot;: &amp;quot;title&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;MongoDB, The Definitive Guide, 1st Edition&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;ISBN&amp;quot;,
        &amp;quot;v&amp;quot;: &amp;quot;xxx&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;author&amp;quot;,
        &amp;quot;v&amp;quot;: &amp;quot;Kristina Chodorow&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;author&amp;quot;,
        &amp;quot;v&amp;quot;: &amp;quot;Mike Dieroff&amp;quot;
      },
      { &amp;quot;k&amp;quot;: &amp;quot;genre&amp;quot;,
        &amp;quot;v&amp;quot;: [&amp;quot;computing&amp;quot;, &amp;quot;databases&amp;quot;] 
      }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  SKU: &amp;quot;Y32944EW&amp;quot;,
  type: &amp;quot;shoes&amp;quot;,
  attr: [
      { &amp;quot;k&amp;quot;: &amp;quot;manufacturer&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;ShoesForAll&amp;quot;,
      },
      { &amp;quot;k&amp;quot;: &amp;quot;color&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;blue&amp;quot;,
      },
      { &amp;quot;k&amp;quot;: &amp;quot;style&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;comfort&amp;quot;,
      },
      { &amp;quot;k&amp;quot;: &amp;quot;size&amp;quot;, 
        &amp;quot;v&amp;quot;: &amp;quot;7B&amp;quot;
      }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that for an attribute that can have multiple values you have a choice of storing it as an array in a single &amp;ldquo;key&amp;rdquo; or you can repeat keys that can have more than one value.&lt;/p&gt;

&lt;p&gt;Now we can index all of these attribute values with the following:&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.ensureIndex( { &#34;attr.k&#34;:1, &#34;attr.v&#34;:1 } )
&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at how the queries will execute and use the index by using the &amp;ldquo;explain()&amp;rdquo; helper in MongoDB shell.  When filtering based on attribute key-value pair, remember to use the &lt;code&gt;$elemMatch&lt;/code&gt; operator to indicate that both conditions must be satisfied by the same element of the array.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.find( 
                                { &#34;attr&#34;: { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;size&#34;, &#34;v&#34;:&#34;8B&#34; } }
                     } ).explain()
{
    &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
    &#34;isMultiKey&#34; : true,
    &#34;n&#34; : 104,
    &#34;nscannedObjects&#34; : 104,
    &#34;nscanned&#34; : 104,
    &#34;nscannedObjectsAllPlans&#34; : 104,
    &#34;nscannedAllPlans&#34; : 104,
    &#34;scanAndOrder&#34; : false,
    &#34;indexOnly&#34; : false,
    &#34;nYields&#34; : 0,
    &#34;nChunkSkips&#34; : 0,
    &#34;millis&#34; : 2,
    &#34;indexBounds&#34; : {
        &#34;attr.k&#34; : [
            [
                &#34;size&#34;,
                &#34;size&#34;
            ]
        ],
        &#34;attr.v&#34; : [
            [
                &#34;8B&#34;,
                &#34;8B&#34;
            ]
        ]
    },
    &#34;server&#34; : &#34;asyasmacbook.local:27017&#34;,
    &#34;filterSet&#34; : false
}
&lt;/pre&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.find(
                  { &#34;attr&#34; :  { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;color&#34;, &#34;v&#34;:&#34;blue&#34;}}
              } ).explain()
{
    &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
    &#34;isMultiKey&#34; : true,
    &#34;n&#34; : 98,
    &#34;nscannedObjects&#34; : 98,
    &#34;nscanned&#34; : 98,
    &#34;nscannedObjectsAllPlans&#34; : 98,
    &#34;nscannedAllPlans&#34; : 98,
    &#34;scanAndOrder&#34; : false,
    &#34;indexOnly&#34; : false,
    &#34;nYields&#34; : 0,
    &#34;nChunkSkips&#34; : 0,
    &#34;millis&#34; : 0,
    &#34;indexBounds&#34; : {
        &#34;attr.k&#34; : [
            [
                &#34;color&#34;,
                &#34;color&#34;
            ]
        ],
        &#34;attr.v&#34; : [
            [
                &#34;blue&#34;,
                &#34;blue&#34;
            ]
        ]
    },
    &#34;server&#34; : &#34;asyasmacbook.local:27017&#34;,
    &#34;filterSet&#34; : false
}
&lt;/pre&gt;

&lt;p&gt;Now I&amp;rsquo;ll use both criteria, and I&amp;rsquo;ll add another one for attribute &amp;ldquo;style&amp;rdquo; - since I want to match only when &lt;em&gt;all&lt;/em&gt; are true (rather than when any is true) I will use the &lt;code&gt;$all&lt;/code&gt; operator.  Passing &amp;ldquo;true&amp;rdquo; as an argument to explain will show all considered plans and not just the winning plan.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-js&#34;&gt;
PRIMARY(2.6.0) &gt; db.products.find( { &#34;attr&#34; : { &#34;$all&#34; : [ 
                    { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;style&#34;, &#34;v&#34;:&#34;comfort&#34; } }, 
                    { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;color&#34;, &#34;v&#34;:&#34;blue&#34; } },
                    { &#34;$elemMatch&#34; : { &#34;k&#34;:&#34;size&#34;, &#34;v&#34;:&#34;8B&#34; } } 
                  ] } } ).explain(true)
{
    &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
    &#34;isMultiKey&#34; : true,
    &#34;n&#34; : 1,
    &#34;nscannedObjects&#34; : 98,
    &#34;nscanned&#34; : 98,
    &#34;nscannedObjectsAllPlans&#34; : 296,
    &#34;nscannedAllPlans&#34; : 298,
    &#34;scanAndOrder&#34; : false,
    &#34;indexOnly&#34; : false,
    &#34;nYields&#34; : 2,
    &#34;nChunkSkips&#34; : 0,
    &#34;millis&#34; : 1,
    &#34;indexBounds&#34; : {
        &#34;attr.k&#34; : [
            [
                &#34;color&#34;,
                &#34;color&#34;
            ]
        ],
        &#34;attr.v&#34; : [
            [
                &#34;blue&#34;,
                &#34;blue&#34;
            ]
        ]
    },
    &#34;allPlans&#34; : [
        {
            &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
            &#34;isMultiKey&#34; : true,
            &#34;n&#34; : 1,
            &#34;nscannedObjects&#34; : 98,
            &#34;nscanned&#34; : 98,
            &#34;scanAndOrder&#34; : false,
            &#34;indexOnly&#34; : false,
            &#34;nChunkSkips&#34; : 0,
            &#34;indexBounds&#34; : {
                &#34;attributes.name&#34; : [
                    [
                        &#34;color&#34;,
                        &#34;color&#34;
                    ]
                ],
                &#34;attributes.value&#34; : [
                    [
                        &#34;blue&#34;,
                        &#34;blue&#34;
                    ]
                ]
            }
        },
        {
            &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
            &#34;isMultiKey&#34; : true,
            &#34;n&#34; : 1,
            &#34;nscannedObjects&#34; : 99,
            &#34;nscanned&#34; : 100,
            &#34;scanAndOrder&#34; : false,
            &#34;indexOnly&#34; : false,
            &#34;nChunkSkips&#34; : 0,
            &#34;indexBounds&#34; : {
                &#34;attributes.name&#34; : [
                    [
                        &#34;style&#34;,
                        &#34;style&#34;
                    ]
                ],
                &#34;attributes.value&#34; : [
                    [
                        &#34;comfort&#34;,
                        &#34;comfort&#34;
                    ]
                ]
            }
        },
        {
            &#34;cursor&#34; : &#34;BtreeCursor attr.k_1_attr.v_1&#34;,
            &#34;isMultiKey&#34; : true,
            &#34;n&#34; : 1,
            &#34;nscannedObjects&#34; : 99,
            &#34;nscanned&#34; : 100,
            &#34;scanAndOrder&#34; : false,
            &#34;indexOnly&#34; : false,
            &#34;nChunkSkips&#34; : 0,
            &#34;indexBounds&#34; : {
                &#34;attributes.name&#34; : [
                    [
                        &#34;size&#34;,
                        &#34;size&#34;
                    ]
                ],
                &#34;attributes.value&#34; : [
                    [
                        &#34;8B&#34;,
                        &#34;8B&#34;
                    ]
                ]
            }
        }
    ],
    &#34;server&#34; : &#34;asyasmacbook.local:27017&#34;,
    &#34;filterSet&#34; : false,
    &#34;stats&#34; : {
        &#34;type&#34; : &#34;KEEP_MUTATIONS&#34;,
        &#34;works&#34; : 100,
        &#34;yields&#34; : 2,
        &#34;unyields&#34; : 2,
        &#34;invalidates&#34; : 0,
        &#34;advanced&#34; : 1,
        &#34;needTime&#34; : 97,
        &#34;needFetch&#34; : 0,
        &#34;isEOF&#34; : 1,
        &#34;children&#34; : [
            {
                &#34;type&#34; : &#34;FETCH&#34;,
                &#34;works&#34; : 99,
                &#34;yields&#34; : 2,
                &#34;unyields&#34; : 2,
                &#34;invalidates&#34; : 0,
                &#34;advanced&#34; : 1,
                &#34;needTime&#34; : 97,
                &#34;needFetch&#34; : 0,
                &#34;isEOF&#34; : 1,
                &#34;alreadyHasObj&#34; : 0,
                &#34;forcedFetches&#34; : 0,
                &#34;matchTested&#34; : 1,
                &#34;children&#34; : [
                    {
                        &#34;type&#34; : &#34;IXSCAN&#34;,
                        &#34;works&#34; : 98,
                        &#34;yields&#34; : 2,
                        &#34;unyields&#34; : 2,
                        &#34;invalidates&#34; : 0,
                        &#34;advanced&#34; : 98,
                        &#34;needTime&#34; : 0,
                        &#34;needFetch&#34; : 0,
                        &#34;isEOF&#34; : 1,
                        &#34;keyPattern&#34; : &#34;{ attr.k: 1.0, attr.v: 1.0 }&#34;,
                        &#34;boundsVerbose&#34; : &#34;field #0[&#39;attr.k&#39;]: [\&#34;color\&#34;, \&#34;color\&#34;], field #1[&#39;attr.v&#39;]: [\&#34;blue\&#34;, \&#34;blue\&#34;]&#34;,
                        &#34;isMultiKey&#34; : 1,
                        &#34;yieldMovedCursor&#34; : 0,
                        &#34;dupsTested&#34; : 98,
                        &#34;dupsDropped&#34; : 0,
                        &#34;seenInvalidated&#34; : 0,
                        &#34;matchTested&#34; : 0,
                        &#34;keysExamined&#34; : 98,
                        &#34;children&#34; : [ ]
                    }
                ]
            }
        ]
    }
}
&lt;/pre&gt;

&lt;p&gt;What does this mean?   If we look at &lt;code&gt;allPlans&lt;/code&gt; we see that the optimizer tried our attribute index separately (but in parallel) with each of the clauses inside the $all array.  The winning plan was for &amp;ldquo;color&amp;rdquo; attribute because it turned out to be the most selective.&lt;/p&gt;

&lt;p&gt;In MongoDB 2.4 this was not possible and unfortunately the optimizer would use the index for the first clause of the &lt;code&gt;$all&lt;/code&gt; expression.  If it happened to have low selectivity, then you didn&amp;rsquo;t get as good performance as you might have, had you ordered your conditions differently.  In 2.6 the order of expressions inside &lt;code&gt;$all&lt;/code&gt; does not make a difference as the one that&amp;rsquo;s most selective will be the one used by the query optimizer.&lt;/p&gt;

&lt;p&gt;Depending on how you need to query your attributes, there are different ways of structuring the attribute array.  You can use key-value pairs as I showed, you can use the attribute name as the key value, or you can even store a single string value &amp;ldquo;attrname::attrvalue&amp;rdquo; - best thing is to take a look at the types of queries and updates you will be running and try it different ways, benchmark which one works best and use that one.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Schema Design - Blog Posts and Comments revisited</title>
          <link>http://asya999.github.io/post/embedorlink/</link>
          <pubDate>Sat, 29 Mar 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://asya999.github.io/post/embedorlink/</guid>
          <description>

&lt;h3 id=&#34;question:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;I have a question about whether I should store comments inside the blog post entry or in a separate collection. It&amp;rsquo;d be nice to see examples of how to access various fields in both cases, how to index and in general how to know when to embed and when to link.&lt;/p&gt;

&lt;h3 id=&#34;answer:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Answer:&lt;/h3&gt;

&lt;h4 id=&#34;the-blog-schema:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;The Blog Schema&lt;/h4&gt;

&lt;p&gt;There has been a lot of discussion and write-ups about how to model a simple blog that allows comments on posts - it&amp;rsquo;s a fairly simple example that everyone can understand, and at the same time it offers several opportunities to choose different ways to structure the schema.  The example usually consists of four concepts: users(or authors), posts, tags on posts and comments on posts.&lt;/p&gt;

&lt;h5 id=&#34;authors:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Authors&lt;/h5&gt;

&lt;p&gt;Typically everyone agrees that the authors or users are stored in a  collection of their own where you keep their information - everything from their username, password, when they last logged in, when they signed up for the service, etc.&lt;/p&gt;

&lt;h5 id=&#34;posts:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Posts&lt;/h5&gt;

&lt;p&gt;There is also little argument that posts should be stored separately from authors - I don&amp;rsquo;t think I&amp;rsquo;ve ever heard anyone advocate for embedding posts within author document - that makes no sense for many reason, not the least of them are the fact that you want to avoid unbounded growth of the author document, and querying over posts is a natural function of the use case so posts really should be first class object.&lt;/p&gt;

&lt;p&gt;What isn&amp;rsquo;t always agreed on is whether the author of the post should have just their unique primary key (or username) saved in each post or whether some of the information, like their full name, should also be denormalized into each post.&lt;/p&gt;

&lt;h5 id=&#34;tags:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Tags&lt;/h5&gt;

&lt;p&gt;Tags being simple strings should be stored inside the post document.  The it advantage of document model over relational is that it allows you to embed an array with multiple values without sacrificing the ability to index the tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ &amp;quot;_id&amp;quot; : &amp;lt;Id&amp;gt;,
    &amp;quot;author&amp;quot; :  { &amp;quot;id&amp;quot; :  &amp;lt;authorId&amp;gt;, &amp;quot;name&amp;quot; :  &amp;quot;Asya Kamsky&amp;quot; },
    &amp;quot;tags&amp;quot; :  [ &amp;quot;schema&amp;quot;, &amp;quot;embed&amp;quot;, &amp;quot;link&amp;quot; ],
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can index tags with &lt;code&gt;db.posts.ensureIndex( { tags:1 } )&lt;/code&gt; which will be used in queries like
    db.posts.find( { &amp;ldquo;tags&amp;rdquo; : { &amp;ldquo;$in&amp;rdquo;:  [&amp;ldquo;schema&amp;rdquo;, &amp;ldquo;performance&amp;rdquo;] } } )&lt;/p&gt;

&lt;p&gt;You probably noticed that I happen to think it&amp;rsquo;s right to denormalize the author&amp;rsquo;s name into the post - I&amp;rsquo;m a strong believer in optimizing for the common case, not exceptional one&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; and I think optimizing query performance is more important than trying to minimize storage at the cost of performance.&lt;/p&gt;

&lt;h5 id=&#34;comments:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Comments&lt;/h5&gt;

&lt;p&gt;Comment documents, or rather where to store them, usually generates the most discussion and disagreement.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s consider both options and see what we can gain from each:&lt;/p&gt;

&lt;h6 id=&#34;embed-comments:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;embed comments&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;{
     _id: &amp;lt;Id&amp;gt;,
     author: { id: &amp;lt;authorId&amp;gt;, name: &amp;quot;Asya Kamsky&amp;quot; },
     tags: [ &amp;quot;schema&amp;quot;, &amp;quot;embed&amp;quot;, &amp;quot;link&amp;quot; ],
     comments: [
         { author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Joe Shmoe&amp;quot;}, 
           date:ISODate(&amp;quot; &amp;quot;), 
           text:&amp;quot;Blah Blah Blah&amp;quot; },
         { author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Jane Doe&amp;quot;}, 
           date:ISODate(&amp;quot; &amp;quot;), 
           text:&amp;quot;Blah Blah Blah&amp;quot; },
         { author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Asya Kamsky&amp;quot;}, 
           date:ISODate(&amp;quot; &amp;quot;), 
           text:&amp;quot;Blah Blah Blah&amp;quot; },
         ...
     ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In addition to other indexes we already plan to have on posts, we will probably need to add several indexes to support querying for comments or by comments.  For example, when someone logs in, I can see wanting to show them all the threads/posts that they commented on, which means we need to index on &amp;ldquo;comments.author.id&amp;rdquo; so that we can query for posts that this author commented on.  We also might need to include fields inside the comments array to track which comments are responses to which other comments, and the biggest downside of them all, if the discussion in comments gets really heated, we will end up with a huge array inside this post.&lt;/p&gt;

&lt;h6 id=&#34;have-separate-comments-collection:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;have separate comments collection&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;{  post : &amp;lt;postId&amp;gt;,
    author : { id:&amp;lt;authorId&amp;gt;,name:&amp;quot;Joe Shmoe&amp;quot;}, 
    date:ISODate(&amp;quot; &amp;quot;), 
    text:&amp;quot;Blah Blah Blah&amp;quot; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A collection of comments would have to have an index on the postId so that we can look up the comments for a particular post, probably compound index with date so that we can query for the most recent posts.  We would want to index author.id and date as well.  But the nice thing is that here we can control how many comments we want returned, and even though querying for all comments for a post might involve some random IO, we can minimize it by only querying for as many comments as we intend to display.  The fact is that most of the time the reader of the blog post won&amp;rsquo;t even look at the comments, and if they do then they might read a few and never click on &amp;ldquo;show more&amp;rdquo; which we would normally have.&lt;/p&gt;

&lt;p&gt;Is there a third option?&lt;/p&gt;

&lt;h6 id=&#34;hybrid-option:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;hybrid option&lt;/h6&gt;

&lt;p&gt;The nice thing about flexible schema is that in cases like these you can keep comments in separate collection but also choose to denormalize some small number of comments into the post itself, either first few or the last few or whatever fits your requirements best.&lt;/p&gt;

&lt;p&gt;This hybrid approach may be analogous to the product collection for an e-commerce site where they store reviews of products separately from the product itself, but keep the highest voted reviews  (one positive and one negative) embedded in the product. This is a good schema because when you display the product, you want to display a few most helpful reviews, but you don&amp;rsquo;t need to display all the reviews at that time.&lt;/p&gt;

&lt;h4 id=&#34;summary:7db8f99d4cb4bf37c187790fa7b90df5&#34;&gt;Summary&lt;/h4&gt;

&lt;p&gt;The general principal to use when trying to decide between embedding and linking is this:
- consider which objects are first class entities and which are properties of such entities
- consider what your use case requires to display fast and what allows for additional queries
- when two choices both seem to be viable, prototype both and see which works better&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;Someone always brings up the possibility that the author will change their name, as if that&amp;rsquo;s an everyday occurrence
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:7db8f99d4cb4bf37c187790fa7b90df5:fn-f1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Why shouldn&#39;t I embed large arrays in my documents?</title>
          <link>http://asya999.github.io/post/largeembeddedarrays/</link>
          <pubDate>Thu, 13 Feb 2014 00:00:00 UTC</pubDate>
          <author></author>
          <guid>http://asya999.github.io/post/largeembeddedarrays/</guid>
          <description>

&lt;h3 id=&#34;question:b03b8c475184befd19c41be5b8f8950d&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;Why shouldn&amp;rsquo;t I embed large arrays in my documents?  It seems incredibly convenient and intuitive but I&amp;rsquo;ve heard there are performance penalties.  What causes them and how do I know if I should avoid using arrays?&lt;/p&gt;

&lt;h3 id=&#34;answer:b03b8c475184befd19c41be5b8f8950d&#34;&gt;Answer:&lt;/h3&gt;

&lt;p&gt;Arrays are wonderful when used properly.  When talking about performance, the main reason to be wary of arrays is when they grow without bounds.&lt;/p&gt;

&lt;p&gt;Imagine you create a document:
&lt;pre class=&#34;prettyprint&#34;&gt;
{ user: &amp;ldquo;Asya&amp;rdquo;,
  email: &amp;ldquo;asya@mongodb.com&amp;rdquo;,
  twitter: [&amp;ldquo;@asya999&amp;rdquo;, &amp;ldquo;@ask-asya&amp;rdquo;]
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Notice that twitter field is an array.  That&amp;rsquo;s perfectly fine and excellent - we don&amp;rsquo;t want to create a separate collection like we&amp;rsquo;d have to do in relational model, just because a person might have multiple twitter accounts/handles.&lt;/p&gt;

&lt;p&gt;Now that the document has been created, a certain amount of space has been allocated for it.  If we continue growing the document by adding new fields to it, it will have to be moved and a larger allocation will be made for it because MongoDB dynamically tracks how often documents outgrow their allocation and tries to allocate more space for newly written or moved documents to account for the future growth.&lt;/p&gt;

&lt;p&gt;Compare the cost of an update to a document when you can make an in-place change, versus rewriting the entire document somewhere else.  First, instead of just rewriting part of a document &amp;ldquo;in place&amp;rdquo; we have to allocate new space for it.  We have to rewrite the entire document, put the space that it used to occupy on the free list so that it can get re-used, and then repoint all the index entries that used to point to the old document location to the new location.  All of this must be done atomically, so your single write suddenly took a bit longer than a few microseconds that it used to take when the document didn&amp;rsquo;t have to move.&lt;/p&gt;

&lt;p&gt;Now imagine what happens if you add a new array field to the document representing something that&amp;rsquo;s not naturally bound the way someone&amp;rsquo;s twitter handles or shipping addresses would be bound.  What if we want to embed into this document every time I perform some activity, let&amp;rsquo;s say click on a like button, or make a comment on someone&amp;rsquo;s blog?&lt;/p&gt;

&lt;p&gt;First of all, we have to consider why we would want to do such a thing.  Normally, I would advise people to embed things that they always want to get back when they are fetching this document.  The flip side of this is that you don&amp;rsquo;t want to embed things in the document that you don&amp;rsquo;t want to get back with it.&lt;/p&gt;

&lt;p&gt;If you embed activity I perform into the document, it&amp;rsquo;ll work great at first because all of my activity is right there and with a single read you can get back everything you might want to show me: &amp;ldquo;you recently clicked on this and here are your last two comments&amp;rdquo; but what happens after six months go by and I don&amp;rsquo;t care about things I did a long time ago and you don&amp;rsquo;t want to show them to me unless I specifically go to look for some old activity?&lt;/p&gt;

&lt;p&gt;First, you&amp;rsquo;ll end up returning bigger and bigger document and caring about smaller and smaller portion of it.  But you can use projection to only return some of the array, the real pain is that the document on disk will get bigger and it will still all be read even if you&amp;rsquo;re only going to return part of it to the end user, but since my activity is not going to stop as long as I&amp;rsquo;m active, the document will continue growing and growing.&lt;/p&gt;

&lt;p&gt;The most obvious problem with this is eventually you&amp;rsquo;ll hit the 16MB document limit, but that&amp;rsquo;s not at all what you should be concerned about.  A document that continuously grows will incur higher and higher cost every time it has to get relocated on disk, and even if you take steps to mitigate the effects of fragmentation, your writes will overall be unnecessarily long, impacting overall performance of your entire application.&lt;/p&gt;

&lt;p&gt;There is one more thing that you can do that will completely kill your application&amp;rsquo;s performance and that&amp;rsquo;s to index this ever-increasing array.  What that means is that every single time the document with this array is relocated, the number of index entries that need to be updated is directly proportional to the number of indexed values in that document, and the bigger the array, the larger that number will be.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t want this to scare you from using arrays when they are a good fit for the data model - they are a powerful feature of the document database data model, but like all powerful tools, it needs to be used in the right circumstances and it should be used with care.&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
